// Code generated by "gobe --allow-unsafe --allow-zero-copy-string ."; DO NOT EDIT.
// versions:
//     gobe: v0.2.1

package types

func (ns25519 *Identity) SizeGOBE() uint64 {
	var ns25520 uint64

	// ZZ: (struct{Version ..IdentityVersion; IdentityV1 ..IdentityV1 "gobe_enum:\"Version=IdentityVersion1\""; ValidFrom int64; ValidUntil int64})(ns25519)

	// ZZ: (..IdentityVersion)(ns25519.Version)

	// ZZ: (uint32)(ns25519.Version)
	ns25520 += 4

	// ZZ: (int64)(ns25519.ValidFrom)
	ns25520 += 8

	// ZZ: (int64)(ns25519.ValidUntil)
	ns25520 += 8
	// ENUM: KEY=<Version>
	switch ns25519.Version {
	case IdentityVersion1: // Version == IdentityVersion1

		// ZZ: (..IdentityV1)(ns25519.IdentityV1)
		ns25520 += ns25519.IdentityV1.SizeGOBE()
	}

	return ns25520
}

func (ns25521 *Identity) MarshalGOBE(dst []byte) uint64 {
	var ns25522 uint64

	// ZZ: (struct{Version ..IdentityVersion; IdentityV1 ..IdentityV1 "gobe_enum:\"Version=IdentityVersion1\""; ValidFrom int64; ValidUntil int64})(ns25521)

	// ZZ: (..IdentityVersion)(ns25521.Version)

	// ZZ: (uint32)(ns25521.Version)
	_ = dst[ns25522+3]
	dst[ns25522+0] = byte(ns25521.Version >> 0)
	dst[ns25522+1] = byte(ns25521.Version >> 8)
	dst[ns25522+2] = byte(ns25521.Version >> 16)
	dst[ns25522+3] = byte(ns25521.Version >> 24)
	ns25522 += 4

	// ZZ: (int64)(ns25521.ValidFrom)
	var ns25523 uint64 = uint64(ns25521.ValidFrom)
	_ = dst[ns25522+7]
	dst[ns25522+0] = byte(ns25523 >> 0)
	dst[ns25522+1] = byte(ns25523 >> 8)
	dst[ns25522+2] = byte(ns25523 >> 16)
	dst[ns25522+3] = byte(ns25523 >> 24)
	dst[ns25522+4] = byte(ns25523 >> 32)
	dst[ns25522+5] = byte(ns25523 >> 40)
	dst[ns25522+6] = byte(ns25523 >> 48)
	dst[ns25522+7] = byte(ns25523 >> 56)
	ns25522 += 8

	// ZZ: (int64)(ns25521.ValidUntil)
	var ns25524 uint64 = uint64(ns25521.ValidUntil)
	_ = dst[ns25522+7]
	dst[ns25522+0] = byte(ns25524 >> 0)
	dst[ns25522+1] = byte(ns25524 >> 8)
	dst[ns25522+2] = byte(ns25524 >> 16)
	dst[ns25522+3] = byte(ns25524 >> 24)
	dst[ns25522+4] = byte(ns25524 >> 32)
	dst[ns25522+5] = byte(ns25524 >> 40)
	dst[ns25522+6] = byte(ns25524 >> 48)
	dst[ns25522+7] = byte(ns25524 >> 56)
	ns25522 += 8
	// ENUM: KEY=<Version>
	switch ns25521.Version {
	case IdentityVersion1: // Version == IdentityVersion1

		// ZZ: (..IdentityV1)(ns25521.IdentityV1)
		ns25522 += ns25521.IdentityV1.MarshalGOBE(dst[ns25522:])
	}

	return ns25522
}

func (ns25525 *Identity) UnmarshalGOBE(src []byte) (offset uint64, ok bool) {

	// ZZ: (struct{Version ..IdentityVersion; IdentityV1 ..IdentityV1 "gobe_enum:\"Version=IdentityVersion1\""; ValidFrom int64; ValidUntil int64})(ns25525)

	// ZZ: (..IdentityVersion)(ns25525.Version)

	// ZZ: (uint32)(ns25525.Version)
	if uint64(len(src)) < offset+4 {
		return
	}
	_ = src[offset+3]
	ns25525.Version = IdentityVersion(
		uint32(src[offset+0])<<0 | uint32(src[offset+1])<<8 | uint32(src[offset+2])<<16 | uint32(src[offset+3])<<24)
	offset += 4

	// ZZ: (int64)(ns25525.ValidFrom)
	if uint64(len(src)) < offset+8 {
		return
	}
	_ = src[offset+7]
	ns25525.ValidFrom = int64(
		uint64(src[offset+0])<<0 | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56)
	offset += 8

	// ZZ: (int64)(ns25525.ValidUntil)
	if uint64(len(src)) < offset+8 {
		return
	}
	_ = src[offset+7]
	ns25525.ValidUntil = int64(
		uint64(src[offset+0])<<0 | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56)
	offset += 8
	// ENUM: KEY=<Version>
	switch ns25525.Version {
	case IdentityVersion1: // Version == IdentityVersion1

		// ZZ: (..IdentityV1)(ns25525.IdentityV1)
		ns25526, ns25527 := ns25525.IdentityV1.UnmarshalGOBE(src[offset:])
		offset += ns25526
		if !ns25527 {
			return
		}
	}

	ok = true
	return
}

func (ns25528 *IdentityV1) SizeGOBE() uint64 {
	var ns25529 uint64

	// ZZ: (struct{Ed25519PublicKey [32]byte; X25519PublicKey [32]byte; MLKEMPublicKey [1568]byte; MLDSAPublicKey [2592]byte})(ns25528)

	// ZZ: ([32]byte)(ns25528.Ed25519PublicKey)
	ns25529 += 32

	// ZZ: ([32]byte)(ns25528.X25519PublicKey)
	ns25529 += 32

	// ZZ: ([1568]byte)(ns25528.MLKEMPublicKey)
	ns25529 += 1568

	// ZZ: ([2592]byte)(ns25528.MLDSAPublicKey)
	ns25529 += 2592

	return ns25529
}

func (ns25530 *IdentityV1) MarshalGOBE(dst []byte) uint64 {
	var ns25531 uint64

	// ZZ: (struct{Ed25519PublicKey [32]byte; X25519PublicKey [32]byte; MLKEMPublicKey [1568]byte; MLDSAPublicKey [2592]byte})(ns25530)

	// ZZ: ([32]byte)(ns25530.Ed25519PublicKey)
	_ = dst[ns25531+31]
	dst[ns25531+0] = ns25530.Ed25519PublicKey[0]
	dst[ns25531+1] = ns25530.Ed25519PublicKey[1]
	dst[ns25531+2] = ns25530.Ed25519PublicKey[2]
	dst[ns25531+3] = ns25530.Ed25519PublicKey[3]
	dst[ns25531+4] = ns25530.Ed25519PublicKey[4]
	dst[ns25531+5] = ns25530.Ed25519PublicKey[5]
	dst[ns25531+6] = ns25530.Ed25519PublicKey[6]
	dst[ns25531+7] = ns25530.Ed25519PublicKey[7]
	dst[ns25531+8] = ns25530.Ed25519PublicKey[8]
	dst[ns25531+9] = ns25530.Ed25519PublicKey[9]
	dst[ns25531+10] = ns25530.Ed25519PublicKey[10]
	dst[ns25531+11] = ns25530.Ed25519PublicKey[11]
	dst[ns25531+12] = ns25530.Ed25519PublicKey[12]
	dst[ns25531+13] = ns25530.Ed25519PublicKey[13]
	dst[ns25531+14] = ns25530.Ed25519PublicKey[14]
	dst[ns25531+15] = ns25530.Ed25519PublicKey[15]
	dst[ns25531+16] = ns25530.Ed25519PublicKey[16]
	dst[ns25531+17] = ns25530.Ed25519PublicKey[17]
	dst[ns25531+18] = ns25530.Ed25519PublicKey[18]
	dst[ns25531+19] = ns25530.Ed25519PublicKey[19]
	dst[ns25531+20] = ns25530.Ed25519PublicKey[20]
	dst[ns25531+21] = ns25530.Ed25519PublicKey[21]
	dst[ns25531+22] = ns25530.Ed25519PublicKey[22]
	dst[ns25531+23] = ns25530.Ed25519PublicKey[23]
	dst[ns25531+24] = ns25530.Ed25519PublicKey[24]
	dst[ns25531+25] = ns25530.Ed25519PublicKey[25]
	dst[ns25531+26] = ns25530.Ed25519PublicKey[26]
	dst[ns25531+27] = ns25530.Ed25519PublicKey[27]
	dst[ns25531+28] = ns25530.Ed25519PublicKey[28]
	dst[ns25531+29] = ns25530.Ed25519PublicKey[29]
	dst[ns25531+30] = ns25530.Ed25519PublicKey[30]
	dst[ns25531+31] = ns25530.Ed25519PublicKey[31]
	ns25531 += 32

	// ZZ: ([32]byte)(ns25530.X25519PublicKey)
	_ = dst[ns25531+31]
	dst[ns25531+0] = ns25530.X25519PublicKey[0]
	dst[ns25531+1] = ns25530.X25519PublicKey[1]
	dst[ns25531+2] = ns25530.X25519PublicKey[2]
	dst[ns25531+3] = ns25530.X25519PublicKey[3]
	dst[ns25531+4] = ns25530.X25519PublicKey[4]
	dst[ns25531+5] = ns25530.X25519PublicKey[5]
	dst[ns25531+6] = ns25530.X25519PublicKey[6]
	dst[ns25531+7] = ns25530.X25519PublicKey[7]
	dst[ns25531+8] = ns25530.X25519PublicKey[8]
	dst[ns25531+9] = ns25530.X25519PublicKey[9]
	dst[ns25531+10] = ns25530.X25519PublicKey[10]
	dst[ns25531+11] = ns25530.X25519PublicKey[11]
	dst[ns25531+12] = ns25530.X25519PublicKey[12]
	dst[ns25531+13] = ns25530.X25519PublicKey[13]
	dst[ns25531+14] = ns25530.X25519PublicKey[14]
	dst[ns25531+15] = ns25530.X25519PublicKey[15]
	dst[ns25531+16] = ns25530.X25519PublicKey[16]
	dst[ns25531+17] = ns25530.X25519PublicKey[17]
	dst[ns25531+18] = ns25530.X25519PublicKey[18]
	dst[ns25531+19] = ns25530.X25519PublicKey[19]
	dst[ns25531+20] = ns25530.X25519PublicKey[20]
	dst[ns25531+21] = ns25530.X25519PublicKey[21]
	dst[ns25531+22] = ns25530.X25519PublicKey[22]
	dst[ns25531+23] = ns25530.X25519PublicKey[23]
	dst[ns25531+24] = ns25530.X25519PublicKey[24]
	dst[ns25531+25] = ns25530.X25519PublicKey[25]
	dst[ns25531+26] = ns25530.X25519PublicKey[26]
	dst[ns25531+27] = ns25530.X25519PublicKey[27]
	dst[ns25531+28] = ns25530.X25519PublicKey[28]
	dst[ns25531+29] = ns25530.X25519PublicKey[29]
	dst[ns25531+30] = ns25530.X25519PublicKey[30]
	dst[ns25531+31] = ns25530.X25519PublicKey[31]
	ns25531 += 32

	// ZZ: ([1568]byte)(ns25530.MLKEMPublicKey)
	copy(dst[ns25531:], ns25530.MLKEMPublicKey[:])
	ns25531 += 1568

	// ZZ: ([2592]byte)(ns25530.MLDSAPublicKey)
	copy(dst[ns25531:], ns25530.MLDSAPublicKey[:])
	ns25531 += 2592

	return ns25531
}

func (ns25532 *IdentityV1) UnmarshalGOBE(src []byte) (offset uint64, ok bool) {

	// ZZ: (struct{Ed25519PublicKey [32]byte; X25519PublicKey [32]byte; MLKEMPublicKey [1568]byte; MLDSAPublicKey [2592]byte})(ns25532)

	// ZZ: ([32]byte)(ns25532.Ed25519PublicKey)
	if uint64(len(src)) < offset+32 {
		return
	}
	_ = src[offset+31]
	ns25532.Ed25519PublicKey[0] = src[offset+0]
	ns25532.Ed25519PublicKey[1] = src[offset+1]
	ns25532.Ed25519PublicKey[2] = src[offset+2]
	ns25532.Ed25519PublicKey[3] = src[offset+3]
	ns25532.Ed25519PublicKey[4] = src[offset+4]
	ns25532.Ed25519PublicKey[5] = src[offset+5]
	ns25532.Ed25519PublicKey[6] = src[offset+6]
	ns25532.Ed25519PublicKey[7] = src[offset+7]
	ns25532.Ed25519PublicKey[8] = src[offset+8]
	ns25532.Ed25519PublicKey[9] = src[offset+9]
	ns25532.Ed25519PublicKey[10] = src[offset+10]
	ns25532.Ed25519PublicKey[11] = src[offset+11]
	ns25532.Ed25519PublicKey[12] = src[offset+12]
	ns25532.Ed25519PublicKey[13] = src[offset+13]
	ns25532.Ed25519PublicKey[14] = src[offset+14]
	ns25532.Ed25519PublicKey[15] = src[offset+15]
	ns25532.Ed25519PublicKey[16] = src[offset+16]
	ns25532.Ed25519PublicKey[17] = src[offset+17]
	ns25532.Ed25519PublicKey[18] = src[offset+18]
	ns25532.Ed25519PublicKey[19] = src[offset+19]
	ns25532.Ed25519PublicKey[20] = src[offset+20]
	ns25532.Ed25519PublicKey[21] = src[offset+21]
	ns25532.Ed25519PublicKey[22] = src[offset+22]
	ns25532.Ed25519PublicKey[23] = src[offset+23]
	ns25532.Ed25519PublicKey[24] = src[offset+24]
	ns25532.Ed25519PublicKey[25] = src[offset+25]
	ns25532.Ed25519PublicKey[26] = src[offset+26]
	ns25532.Ed25519PublicKey[27] = src[offset+27]
	ns25532.Ed25519PublicKey[28] = src[offset+28]
	ns25532.Ed25519PublicKey[29] = src[offset+29]
	ns25532.Ed25519PublicKey[30] = src[offset+30]
	ns25532.Ed25519PublicKey[31] = src[offset+31]
	offset += 32

	// ZZ: ([32]byte)(ns25532.X25519PublicKey)
	if uint64(len(src)) < offset+32 {
		return
	}
	_ = src[offset+31]
	ns25532.X25519PublicKey[0] = src[offset+0]
	ns25532.X25519PublicKey[1] = src[offset+1]
	ns25532.X25519PublicKey[2] = src[offset+2]
	ns25532.X25519PublicKey[3] = src[offset+3]
	ns25532.X25519PublicKey[4] = src[offset+4]
	ns25532.X25519PublicKey[5] = src[offset+5]
	ns25532.X25519PublicKey[6] = src[offset+6]
	ns25532.X25519PublicKey[7] = src[offset+7]
	ns25532.X25519PublicKey[8] = src[offset+8]
	ns25532.X25519PublicKey[9] = src[offset+9]
	ns25532.X25519PublicKey[10] = src[offset+10]
	ns25532.X25519PublicKey[11] = src[offset+11]
	ns25532.X25519PublicKey[12] = src[offset+12]
	ns25532.X25519PublicKey[13] = src[offset+13]
	ns25532.X25519PublicKey[14] = src[offset+14]
	ns25532.X25519PublicKey[15] = src[offset+15]
	ns25532.X25519PublicKey[16] = src[offset+16]
	ns25532.X25519PublicKey[17] = src[offset+17]
	ns25532.X25519PublicKey[18] = src[offset+18]
	ns25532.X25519PublicKey[19] = src[offset+19]
	ns25532.X25519PublicKey[20] = src[offset+20]
	ns25532.X25519PublicKey[21] = src[offset+21]
	ns25532.X25519PublicKey[22] = src[offset+22]
	ns25532.X25519PublicKey[23] = src[offset+23]
	ns25532.X25519PublicKey[24] = src[offset+24]
	ns25532.X25519PublicKey[25] = src[offset+25]
	ns25532.X25519PublicKey[26] = src[offset+26]
	ns25532.X25519PublicKey[27] = src[offset+27]
	ns25532.X25519PublicKey[28] = src[offset+28]
	ns25532.X25519PublicKey[29] = src[offset+29]
	ns25532.X25519PublicKey[30] = src[offset+30]
	ns25532.X25519PublicKey[31] = src[offset+31]
	offset += 32

	// ZZ: ([1568]byte)(ns25532.MLKEMPublicKey)
	if uint64(len(src)) < offset+1568 {
		return
	}
	copy(ns25532.MLKEMPublicKey[:], src[offset:])
	offset += 1568

	// ZZ: ([2592]byte)(ns25532.MLDSAPublicKey)
	if uint64(len(src)) < offset+2592 {
		return
	}
	copy(ns25532.MLDSAPublicKey[:], src[offset:])
	offset += 2592

	ok = true
	return
}

func (ns25533 *IdentityVersion) SizeGOBE() uint64 {
	var ns25534 uint64

	// ZZ: (..IdentityVersion)(*ns25533)

	// ZZ: (uint32)(*ns25533)
	ns25534 += 4

	return ns25534
}

func (ns25535 *IdentityVersion) MarshalGOBE(dst []byte) uint64 {
	var ns25536 uint64

	// ZZ: (..IdentityVersion)(*ns25535)

	// ZZ: (uint32)(*ns25535)
	_ = dst[ns25536+3]
	dst[ns25536+0] = byte(*ns25535 >> 0)
	dst[ns25536+1] = byte(*ns25535 >> 8)
	dst[ns25536+2] = byte(*ns25535 >> 16)
	dst[ns25536+3] = byte(*ns25535 >> 24)
	ns25536 += 4

	return ns25536
}

func (ns25537 *IdentityVersion) UnmarshalGOBE(src []byte) (offset uint64, ok bool) {

	// ZZ: (..IdentityVersion)(*ns25537)

	// ZZ: (uint32)(*ns25537)
	if uint64(len(src)) < offset+4 {
		return
	}
	_ = src[offset+3]
	*ns25537 = IdentityVersion(
		uint32(src[offset+0])<<0 | uint32(src[offset+1])<<8 | uint32(src[offset+2])<<16 | uint32(src[offset+3])<<24)
	offset += 4

	ok = true
	return
}

func (ns25538 *MessageType) SizeGOBE() uint64 {
	var ns25539 uint64

	// ZZ: (..MessageType)(*ns25538)

	// ZZ: (uint16)(*ns25538)
	ns25539 += 2

	return ns25539
}

func (ns25540 *MessageType) MarshalGOBE(dst []byte) uint64 {
	var ns25541 uint64

	// ZZ: (..MessageType)(*ns25540)

	// ZZ: (uint16)(*ns25540)
	_ = dst[ns25541+1]
	dst[ns25541+0] = byte(*ns25540 >> 0)
	dst[ns25541+1] = byte(*ns25540 >> 8)
	ns25541 += 2

	return ns25541
}

func (ns25542 *MessageType) UnmarshalGOBE(src []byte) (offset uint64, ok bool) {

	// ZZ: (..MessageType)(*ns25542)

	// ZZ: (uint16)(*ns25542)
	if uint64(len(src)) < offset+2 {
		return
	}
	_ = src[offset+1]
	*ns25542 = MessageType(
		uint16(src[offset+0])<<0 | uint16(src[offset+1])<<8)
	offset += 2

	ok = true
	return
}

func (ns25543 *MessageV1) SizeGOBE() uint64 {
	var ns25544 uint64

	// ZZ: (struct{SessionID uint64; Type ..MessageType; MessageV1SyncRequest ..MessageV1SyncRequest "gobe_enum:\"Type=MessageTypeSyncRequest\""; MessageV1SyncResponse ..MessageV1SyncResponse "gobe_enum:\"Type=MessageTypeSyncResponse\""})(ns25543)

	// ZZ: (uint64)(ns25543.SessionID)
	ns25544 += 8

	// ZZ: (..MessageType)(ns25543.Type)

	// ZZ: (uint16)(ns25543.Type)
	ns25544 += 2
	// ENUM: KEY=<Type>
	switch ns25543.Type {
	case MessageTypeSyncRequest: // Type == MessageTypeSyncRequest

		// ZZ: (..MessageV1SyncRequest)(ns25543.MessageV1SyncRequest)
		ns25544 += ns25543.MessageV1SyncRequest.SizeGOBE()
	case MessageTypeSyncResponse: // Type == MessageTypeSyncResponse

		// ZZ: (..MessageV1SyncResponse)(ns25543.MessageV1SyncResponse)
		ns25544 += ns25543.MessageV1SyncResponse.SizeGOBE()
	}

	return ns25544
}

func (ns25545 *MessageV1) MarshalGOBE(dst []byte) uint64 {
	var ns25546 uint64

	// ZZ: (struct{SessionID uint64; Type ..MessageType; MessageV1SyncRequest ..MessageV1SyncRequest "gobe_enum:\"Type=MessageTypeSyncRequest\""; MessageV1SyncResponse ..MessageV1SyncResponse "gobe_enum:\"Type=MessageTypeSyncResponse\""})(ns25545)

	// ZZ: (uint64)(ns25545.SessionID)
	_ = dst[ns25546+7]
	dst[ns25546+0] = byte(ns25545.SessionID >> 0)
	dst[ns25546+1] = byte(ns25545.SessionID >> 8)
	dst[ns25546+2] = byte(ns25545.SessionID >> 16)
	dst[ns25546+3] = byte(ns25545.SessionID >> 24)
	dst[ns25546+4] = byte(ns25545.SessionID >> 32)
	dst[ns25546+5] = byte(ns25545.SessionID >> 40)
	dst[ns25546+6] = byte(ns25545.SessionID >> 48)
	dst[ns25546+7] = byte(ns25545.SessionID >> 56)
	ns25546 += 8

	// ZZ: (..MessageType)(ns25545.Type)

	// ZZ: (uint16)(ns25545.Type)
	_ = dst[ns25546+1]
	dst[ns25546+0] = byte(ns25545.Type >> 0)
	dst[ns25546+1] = byte(ns25545.Type >> 8)
	ns25546 += 2
	// ENUM: KEY=<Type>
	switch ns25545.Type {
	case MessageTypeSyncRequest: // Type == MessageTypeSyncRequest

		// ZZ: (..MessageV1SyncRequest)(ns25545.MessageV1SyncRequest)
		ns25546 += ns25545.MessageV1SyncRequest.MarshalGOBE(dst[ns25546:])
	case MessageTypeSyncResponse: // Type == MessageTypeSyncResponse

		// ZZ: (..MessageV1SyncResponse)(ns25545.MessageV1SyncResponse)
		ns25546 += ns25545.MessageV1SyncResponse.MarshalGOBE(dst[ns25546:])
	}

	return ns25546
}

func (ns25547 *MessageV1) UnmarshalGOBE(src []byte) (offset uint64, ok bool) {

	// ZZ: (struct{SessionID uint64; Type ..MessageType; MessageV1SyncRequest ..MessageV1SyncRequest "gobe_enum:\"Type=MessageTypeSyncRequest\""; MessageV1SyncResponse ..MessageV1SyncResponse "gobe_enum:\"Type=MessageTypeSyncResponse\""})(ns25547)

	// ZZ: (uint64)(ns25547.SessionID)
	if uint64(len(src)) < offset+8 {
		return
	}
	_ = src[offset+7]
	ns25547.SessionID = uint64(
		uint64(src[offset+0])<<0 | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56)
	offset += 8

	// ZZ: (..MessageType)(ns25547.Type)

	// ZZ: (uint16)(ns25547.Type)
	if uint64(len(src)) < offset+2 {
		return
	}
	_ = src[offset+1]
	ns25547.Type = MessageType(
		uint16(src[offset+0])<<0 | uint16(src[offset+1])<<8)
	offset += 2
	// ENUM: KEY=<Type>
	switch ns25547.Type {
	case MessageTypeSyncRequest: // Type == MessageTypeSyncRequest

		// ZZ: (..MessageV1SyncRequest)(ns25547.MessageV1SyncRequest)
		ns25548, ns25549 := ns25547.MessageV1SyncRequest.UnmarshalGOBE(src[offset:])
		offset += ns25548
		if !ns25549 {
			return
		}
	case MessageTypeSyncResponse: // Type == MessageTypeSyncResponse

		// ZZ: (..MessageV1SyncResponse)(ns25547.MessageV1SyncResponse)
		ns25550, ns25551 := ns25547.MessageV1SyncResponse.UnmarshalGOBE(src[offset:])
		offset += ns25550
		if !ns25551 {
			return
		}
	}

	ok = true
	return
}

func (ns25552 *MessageV1Encrypted) SizeGOBE() uint64 {
	var ns25553 uint64

	// ZZ: (struct{SessionID uint64; KeyID [16]byte; Nonce [24]byte; AuthData [16]byte; Payload []byte})(ns25552)

	// ZZ: (uint64)(ns25552.SessionID)
	ns25553 += 8

	// ZZ: ([16]byte)(ns25552.KeyID)
	ns25553 += 16

	// ZZ: ([24]byte)(ns25552.Nonce)
	ns25553 += 24

	// ZZ: ([16]byte)(ns25552.AuthData)
	ns25553 += 16

	// ZZ: ([]byte)(ns25552.Payload)
	ns25553 += 8 + uint64(len(ns25552.Payload))

	return ns25553
}

func (ns25554 *MessageV1Encrypted) MarshalGOBE(dst []byte) uint64 {
	var ns25555 uint64

	// ZZ: (struct{SessionID uint64; KeyID [16]byte; Nonce [24]byte; AuthData [16]byte; Payload []byte})(ns25554)

	// ZZ: (uint64)(ns25554.SessionID)
	_ = dst[ns25555+7]
	dst[ns25555+0] = byte(ns25554.SessionID >> 0)
	dst[ns25555+1] = byte(ns25554.SessionID >> 8)
	dst[ns25555+2] = byte(ns25554.SessionID >> 16)
	dst[ns25555+3] = byte(ns25554.SessionID >> 24)
	dst[ns25555+4] = byte(ns25554.SessionID >> 32)
	dst[ns25555+5] = byte(ns25554.SessionID >> 40)
	dst[ns25555+6] = byte(ns25554.SessionID >> 48)
	dst[ns25555+7] = byte(ns25554.SessionID >> 56)
	ns25555 += 8

	// ZZ: ([16]byte)(ns25554.KeyID)
	_ = dst[ns25555+15]
	dst[ns25555+0] = ns25554.KeyID[0]
	dst[ns25555+1] = ns25554.KeyID[1]
	dst[ns25555+2] = ns25554.KeyID[2]
	dst[ns25555+3] = ns25554.KeyID[3]
	dst[ns25555+4] = ns25554.KeyID[4]
	dst[ns25555+5] = ns25554.KeyID[5]
	dst[ns25555+6] = ns25554.KeyID[6]
	dst[ns25555+7] = ns25554.KeyID[7]
	dst[ns25555+8] = ns25554.KeyID[8]
	dst[ns25555+9] = ns25554.KeyID[9]
	dst[ns25555+10] = ns25554.KeyID[10]
	dst[ns25555+11] = ns25554.KeyID[11]
	dst[ns25555+12] = ns25554.KeyID[12]
	dst[ns25555+13] = ns25554.KeyID[13]
	dst[ns25555+14] = ns25554.KeyID[14]
	dst[ns25555+15] = ns25554.KeyID[15]
	ns25555 += 16

	// ZZ: ([24]byte)(ns25554.Nonce)
	_ = dst[ns25555+23]
	dst[ns25555+0] = ns25554.Nonce[0]
	dst[ns25555+1] = ns25554.Nonce[1]
	dst[ns25555+2] = ns25554.Nonce[2]
	dst[ns25555+3] = ns25554.Nonce[3]
	dst[ns25555+4] = ns25554.Nonce[4]
	dst[ns25555+5] = ns25554.Nonce[5]
	dst[ns25555+6] = ns25554.Nonce[6]
	dst[ns25555+7] = ns25554.Nonce[7]
	dst[ns25555+8] = ns25554.Nonce[8]
	dst[ns25555+9] = ns25554.Nonce[9]
	dst[ns25555+10] = ns25554.Nonce[10]
	dst[ns25555+11] = ns25554.Nonce[11]
	dst[ns25555+12] = ns25554.Nonce[12]
	dst[ns25555+13] = ns25554.Nonce[13]
	dst[ns25555+14] = ns25554.Nonce[14]
	dst[ns25555+15] = ns25554.Nonce[15]
	dst[ns25555+16] = ns25554.Nonce[16]
	dst[ns25555+17] = ns25554.Nonce[17]
	dst[ns25555+18] = ns25554.Nonce[18]
	dst[ns25555+19] = ns25554.Nonce[19]
	dst[ns25555+20] = ns25554.Nonce[20]
	dst[ns25555+21] = ns25554.Nonce[21]
	dst[ns25555+22] = ns25554.Nonce[22]
	dst[ns25555+23] = ns25554.Nonce[23]
	ns25555 += 24

	// ZZ: ([16]byte)(ns25554.AuthData)
	_ = dst[ns25555+15]
	dst[ns25555+0] = ns25554.AuthData[0]
	dst[ns25555+1] = ns25554.AuthData[1]
	dst[ns25555+2] = ns25554.AuthData[2]
	dst[ns25555+3] = ns25554.AuthData[3]
	dst[ns25555+4] = ns25554.AuthData[4]
	dst[ns25555+5] = ns25554.AuthData[5]
	dst[ns25555+6] = ns25554.AuthData[6]
	dst[ns25555+7] = ns25554.AuthData[7]
	dst[ns25555+8] = ns25554.AuthData[8]
	dst[ns25555+9] = ns25554.AuthData[9]
	dst[ns25555+10] = ns25554.AuthData[10]
	dst[ns25555+11] = ns25554.AuthData[11]
	dst[ns25555+12] = ns25554.AuthData[12]
	dst[ns25555+13] = ns25554.AuthData[13]
	dst[ns25555+14] = ns25554.AuthData[14]
	dst[ns25555+15] = ns25554.AuthData[15]
	ns25555 += 16

	// ZZ: ([]byte)(ns25554.Payload)
	var ns25556 uint64 = uint64(len(ns25554.Payload))
	_ = dst[ns25555+7]
	dst[ns25555+0] = byte(ns25556 >> 0)
	dst[ns25555+1] = byte(ns25556 >> 8)
	dst[ns25555+2] = byte(ns25556 >> 16)
	dst[ns25555+3] = byte(ns25556 >> 24)
	dst[ns25555+4] = byte(ns25556 >> 32)
	dst[ns25555+5] = byte(ns25556 >> 40)
	dst[ns25555+6] = byte(ns25556 >> 48)
	dst[ns25555+7] = byte(ns25556 >> 56)
	copy(dst[ns25555+8:], ns25554.Payload)
	ns25555 += 8 + ns25556

	return ns25555
}

func (ns25557 *MessageV1Encrypted) UnmarshalGOBE(src []byte) (offset uint64, ok bool) {

	// ZZ: (struct{SessionID uint64; KeyID [16]byte; Nonce [24]byte; AuthData [16]byte; Payload []byte})(ns25557)

	// ZZ: (uint64)(ns25557.SessionID)
	if uint64(len(src)) < offset+8 {
		return
	}
	_ = src[offset+7]
	ns25557.SessionID = uint64(
		uint64(src[offset+0])<<0 | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56)
	offset += 8

	// ZZ: ([16]byte)(ns25557.KeyID)
	if uint64(len(src)) < offset+16 {
		return
	}
	_ = src[offset+15]
	ns25557.KeyID[0] = src[offset+0]
	ns25557.KeyID[1] = src[offset+1]
	ns25557.KeyID[2] = src[offset+2]
	ns25557.KeyID[3] = src[offset+3]
	ns25557.KeyID[4] = src[offset+4]
	ns25557.KeyID[5] = src[offset+5]
	ns25557.KeyID[6] = src[offset+6]
	ns25557.KeyID[7] = src[offset+7]
	ns25557.KeyID[8] = src[offset+8]
	ns25557.KeyID[9] = src[offset+9]
	ns25557.KeyID[10] = src[offset+10]
	ns25557.KeyID[11] = src[offset+11]
	ns25557.KeyID[12] = src[offset+12]
	ns25557.KeyID[13] = src[offset+13]
	ns25557.KeyID[14] = src[offset+14]
	ns25557.KeyID[15] = src[offset+15]
	offset += 16

	// ZZ: ([24]byte)(ns25557.Nonce)
	if uint64(len(src)) < offset+24 {
		return
	}
	_ = src[offset+23]
	ns25557.Nonce[0] = src[offset+0]
	ns25557.Nonce[1] = src[offset+1]
	ns25557.Nonce[2] = src[offset+2]
	ns25557.Nonce[3] = src[offset+3]
	ns25557.Nonce[4] = src[offset+4]
	ns25557.Nonce[5] = src[offset+5]
	ns25557.Nonce[6] = src[offset+6]
	ns25557.Nonce[7] = src[offset+7]
	ns25557.Nonce[8] = src[offset+8]
	ns25557.Nonce[9] = src[offset+9]
	ns25557.Nonce[10] = src[offset+10]
	ns25557.Nonce[11] = src[offset+11]
	ns25557.Nonce[12] = src[offset+12]
	ns25557.Nonce[13] = src[offset+13]
	ns25557.Nonce[14] = src[offset+14]
	ns25557.Nonce[15] = src[offset+15]
	ns25557.Nonce[16] = src[offset+16]
	ns25557.Nonce[17] = src[offset+17]
	ns25557.Nonce[18] = src[offset+18]
	ns25557.Nonce[19] = src[offset+19]
	ns25557.Nonce[20] = src[offset+20]
	ns25557.Nonce[21] = src[offset+21]
	ns25557.Nonce[22] = src[offset+22]
	ns25557.Nonce[23] = src[offset+23]
	offset += 24

	// ZZ: ([16]byte)(ns25557.AuthData)
	if uint64(len(src)) < offset+16 {
		return
	}
	_ = src[offset+15]
	ns25557.AuthData[0] = src[offset+0]
	ns25557.AuthData[1] = src[offset+1]
	ns25557.AuthData[2] = src[offset+2]
	ns25557.AuthData[3] = src[offset+3]
	ns25557.AuthData[4] = src[offset+4]
	ns25557.AuthData[5] = src[offset+5]
	ns25557.AuthData[6] = src[offset+6]
	ns25557.AuthData[7] = src[offset+7]
	ns25557.AuthData[8] = src[offset+8]
	ns25557.AuthData[9] = src[offset+9]
	ns25557.AuthData[10] = src[offset+10]
	ns25557.AuthData[11] = src[offset+11]
	ns25557.AuthData[12] = src[offset+12]
	ns25557.AuthData[13] = src[offset+13]
	ns25557.AuthData[14] = src[offset+14]
	ns25557.AuthData[15] = src[offset+15]
	offset += 16

	// ZZ: ([]byte)(ns25557.Payload)
	if uint64(len(src)) < offset+8 {
		return
	}
	_ = src[offset+7]
	var ns25558 uint64 = uint64(src[offset]) | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56
	offset += 8
	if uint64(len(src)) < offset+ns25558 {
		return
	}
	ns25557.Payload = src[offset : offset+ns25558]
	offset += ns25558

	ok = true
	return
}

func (ns25559 *MessageV1SyncRequest) SizeGOBE() uint64 {
	var ns25560 uint64

	// ZZ: (struct{LastOffset int64; MaxEntries int64})(ns25559)

	// ZZ: (int64)(ns25559.LastOffset)
	ns25560 += 8

	// ZZ: (int64)(ns25559.MaxEntries)
	ns25560 += 8

	return ns25560
}

func (ns25561 *MessageV1SyncRequest) MarshalGOBE(dst []byte) uint64 {
	var ns25562 uint64

	// ZZ: (struct{LastOffset int64; MaxEntries int64})(ns25561)

	// ZZ: (int64)(ns25561.LastOffset)
	var ns25563 uint64 = uint64(ns25561.LastOffset)
	_ = dst[ns25562+7]
	dst[ns25562+0] = byte(ns25563 >> 0)
	dst[ns25562+1] = byte(ns25563 >> 8)
	dst[ns25562+2] = byte(ns25563 >> 16)
	dst[ns25562+3] = byte(ns25563 >> 24)
	dst[ns25562+4] = byte(ns25563 >> 32)
	dst[ns25562+5] = byte(ns25563 >> 40)
	dst[ns25562+6] = byte(ns25563 >> 48)
	dst[ns25562+7] = byte(ns25563 >> 56)
	ns25562 += 8

	// ZZ: (int64)(ns25561.MaxEntries)
	var ns25564 uint64 = uint64(ns25561.MaxEntries)
	_ = dst[ns25562+7]
	dst[ns25562+0] = byte(ns25564 >> 0)
	dst[ns25562+1] = byte(ns25564 >> 8)
	dst[ns25562+2] = byte(ns25564 >> 16)
	dst[ns25562+3] = byte(ns25564 >> 24)
	dst[ns25562+4] = byte(ns25564 >> 32)
	dst[ns25562+5] = byte(ns25564 >> 40)
	dst[ns25562+6] = byte(ns25564 >> 48)
	dst[ns25562+7] = byte(ns25564 >> 56)
	ns25562 += 8

	return ns25562
}

func (ns25565 *MessageV1SyncRequest) UnmarshalGOBE(src []byte) (offset uint64, ok bool) {

	// ZZ: (struct{LastOffset int64; MaxEntries int64})(ns25565)

	// ZZ: (int64)(ns25565.LastOffset)
	if uint64(len(src)) < offset+8 {
		return
	}
	_ = src[offset+7]
	ns25565.LastOffset = int64(
		uint64(src[offset+0])<<0 | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56)
	offset += 8

	// ZZ: (int64)(ns25565.MaxEntries)
	if uint64(len(src)) < offset+8 {
		return
	}
	_ = src[offset+7]
	ns25565.MaxEntries = int64(
		uint64(src[offset+0])<<0 | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56)
	offset += 8

	ok = true
	return
}

func (ns25566 *MessageV1SyncResponse) SizeGOBE() uint64 {
	var ns25567 uint64

	// ZZ: (struct{CommittedOffset int64; Entries [][]byte})(ns25566)

	// ZZ: (int64)(ns25566.CommittedOffset)
	ns25567 += 8

	// ZZ: ([][]byte)(ns25566.Entries)
	ns25567 += 8
	for ns25568 := 0; ns25568 < len(ns25566.Entries); ns25568++ {

		// ZZ: ([]byte)(ns25566.Entries[ns25568])
		ns25567 += 8 + uint64(len(ns25566.Entries[ns25568]))
	}

	return ns25567
}

func (ns25569 *MessageV1SyncResponse) MarshalGOBE(dst []byte) uint64 {
	var ns25570 uint64

	// ZZ: (struct{CommittedOffset int64; Entries [][]byte})(ns25569)

	// ZZ: (int64)(ns25569.CommittedOffset)
	var ns25571 uint64 = uint64(ns25569.CommittedOffset)
	_ = dst[ns25570+7]
	dst[ns25570+0] = byte(ns25571 >> 0)
	dst[ns25570+1] = byte(ns25571 >> 8)
	dst[ns25570+2] = byte(ns25571 >> 16)
	dst[ns25570+3] = byte(ns25571 >> 24)
	dst[ns25570+4] = byte(ns25571 >> 32)
	dst[ns25570+5] = byte(ns25571 >> 40)
	dst[ns25570+6] = byte(ns25571 >> 48)
	dst[ns25570+7] = byte(ns25571 >> 56)
	ns25570 += 8

	// ZZ: ([][]byte)(ns25569.Entries)
	var ns25572 uint64 = uint64(len(ns25569.Entries))
	_ = dst[ns25570+7]
	dst[ns25570+0] = byte(ns25572 >> 0)
	dst[ns25570+1] = byte(ns25572 >> 8)
	dst[ns25570+2] = byte(ns25572 >> 16)
	dst[ns25570+3] = byte(ns25572 >> 24)
	dst[ns25570+4] = byte(ns25572 >> 32)
	dst[ns25570+5] = byte(ns25572 >> 40)
	dst[ns25570+6] = byte(ns25572 >> 48)
	dst[ns25570+7] = byte(ns25572 >> 56)
	ns25570 += 8

	for ns25573 := 0; ns25573 < len(ns25569.Entries); ns25573++ {

		// ZZ: ([]byte)(ns25569.Entries[ns25573])
		var ns25574 uint64 = uint64(len(ns25569.Entries[ns25573]))
		_ = dst[ns25570+7]
		dst[ns25570+0] = byte(ns25574 >> 0)
		dst[ns25570+1] = byte(ns25574 >> 8)
		dst[ns25570+2] = byte(ns25574 >> 16)
		dst[ns25570+3] = byte(ns25574 >> 24)
		dst[ns25570+4] = byte(ns25574 >> 32)
		dst[ns25570+5] = byte(ns25574 >> 40)
		dst[ns25570+6] = byte(ns25574 >> 48)
		dst[ns25570+7] = byte(ns25574 >> 56)
		copy(dst[ns25570+8:], ns25569.Entries[ns25573])
		ns25570 += 8 + ns25574

	}

	return ns25570
}

func (ns25575 *MessageV1SyncResponse) UnmarshalGOBE(src []byte) (offset uint64, ok bool) {

	// ZZ: (struct{CommittedOffset int64; Entries [][]byte})(ns25575)

	// ZZ: (int64)(ns25575.CommittedOffset)
	if uint64(len(src)) < offset+8 {
		return
	}
	_ = src[offset+7]
	ns25575.CommittedOffset = int64(
		uint64(src[offset+0])<<0 | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56)
	offset += 8

	// ZZ: ([][]byte)(ns25575.Entries)
	if uint64(len(src)) < offset+8 {
		return
	}
	_ = src[offset+7]
	var ns25576 uint64 = uint64(src[offset]) | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56
	offset += 8
	if uint64(cap(ns25575.Entries)) < ns25576 {
		if ns25576*uint64(24) <= 1<<15 {
			ns25575.Entries = make([][]byte, ns25576)
			for ns25577 := uint64(0); ns25577 < ns25576; ns25577++ {

				// ZZ: ([]byte)(ns25575.Entries[ns25577])
				if uint64(len(src)) < offset+8 {
					return
				}
				_ = src[offset+7]
				var ns25579 uint64 = uint64(src[offset]) | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56
				offset += 8
				if uint64(len(src)) < offset+ns25579 {
					return
				}
				ns25575.Entries[ns25577] = src[offset : offset+ns25579]
				offset += ns25579
			}
		} else {
			// Slice too large, Using Append
			ns25575.Entries = ns25575.Entries[:0]
			for ns25577 := uint64(0); ns25577 < ns25576; ns25577++ {
				var ns25578 []byte

				// ZZ: ([]byte)(ns25578)
				if uint64(len(src)) < offset+8 {
					return
				}
				_ = src[offset+7]
				var ns25580 uint64 = uint64(src[offset]) | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56
				offset += 8
				if uint64(len(src)) < offset+ns25580 {
					return
				}
				ns25578 = src[offset : offset+ns25580]
				offset += ns25580
				ns25575.Entries = append(ns25575.Entries, ns25578)
			}
		}
	} else {
		ns25575.Entries = ns25575.Entries[:ns25576]
		for ns25577 := uint64(0); ns25577 < ns25576; ns25577++ {

			// ZZ: ([]byte)(ns25575.Entries[ns25577])
			if uint64(len(src)) < offset+8 {
				return
			}
			_ = src[offset+7]
			var ns25581 uint64 = uint64(src[offset]) | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56
			offset += 8
			if uint64(len(src)) < offset+ns25581 {
				return
			}
			ns25575.Entries[ns25577] = src[offset : offset+ns25581]
			offset += ns25581
		}
	}

	ok = true
	return
}

func (ns25582 *Packet) SizeGOBE() uint64 {
	var ns25583 uint64

	// ZZ: (struct{Version ..ProtocolVersion; MessageV1 ..MessageV1 "gobe_enum:\"Version=ProtocolVersion1\""; MessageV1Encrypted ..MessageV1Encrypted "gobe_enum:\"Version=ProtocolVersion1Encrypted\""})(ns25582)

	// ZZ: (..ProtocolVersion)(ns25582.Version)

	// ZZ: (uint32)(ns25582.Version)
	ns25583 += 4
	// ENUM: KEY=<Version>
	switch ns25582.Version {
	case ProtocolVersion1: // Version == ProtocolVersion1

		// ZZ: (..MessageV1)(ns25582.MessageV1)
		ns25583 += ns25582.MessageV1.SizeGOBE()
	case ProtocolVersion1Encrypted: // Version == ProtocolVersion1Encrypted

		// ZZ: (..MessageV1Encrypted)(ns25582.MessageV1Encrypted)
		ns25583 += ns25582.MessageV1Encrypted.SizeGOBE()
	}

	return ns25583
}

func (ns25584 *Packet) MarshalGOBE(dst []byte) uint64 {
	var ns25585 uint64

	// ZZ: (struct{Version ..ProtocolVersion; MessageV1 ..MessageV1 "gobe_enum:\"Version=ProtocolVersion1\""; MessageV1Encrypted ..MessageV1Encrypted "gobe_enum:\"Version=ProtocolVersion1Encrypted\""})(ns25584)

	// ZZ: (..ProtocolVersion)(ns25584.Version)

	// ZZ: (uint32)(ns25584.Version)
	_ = dst[ns25585+3]
	dst[ns25585+0] = byte(ns25584.Version >> 0)
	dst[ns25585+1] = byte(ns25584.Version >> 8)
	dst[ns25585+2] = byte(ns25584.Version >> 16)
	dst[ns25585+3] = byte(ns25584.Version >> 24)
	ns25585 += 4
	// ENUM: KEY=<Version>
	switch ns25584.Version {
	case ProtocolVersion1: // Version == ProtocolVersion1

		// ZZ: (..MessageV1)(ns25584.MessageV1)
		ns25585 += ns25584.MessageV1.MarshalGOBE(dst[ns25585:])
	case ProtocolVersion1Encrypted: // Version == ProtocolVersion1Encrypted

		// ZZ: (..MessageV1Encrypted)(ns25584.MessageV1Encrypted)
		ns25585 += ns25584.MessageV1Encrypted.MarshalGOBE(dst[ns25585:])
	}

	return ns25585
}

func (ns25586 *Packet) UnmarshalGOBE(src []byte) (offset uint64, ok bool) {

	// ZZ: (struct{Version ..ProtocolVersion; MessageV1 ..MessageV1 "gobe_enum:\"Version=ProtocolVersion1\""; MessageV1Encrypted ..MessageV1Encrypted "gobe_enum:\"Version=ProtocolVersion1Encrypted\""})(ns25586)

	// ZZ: (..ProtocolVersion)(ns25586.Version)

	// ZZ: (uint32)(ns25586.Version)
	if uint64(len(src)) < offset+4 {
		return
	}
	_ = src[offset+3]
	ns25586.Version = ProtocolVersion(
		uint32(src[offset+0])<<0 | uint32(src[offset+1])<<8 | uint32(src[offset+2])<<16 | uint32(src[offset+3])<<24)
	offset += 4
	// ENUM: KEY=<Version>
	switch ns25586.Version {
	case ProtocolVersion1: // Version == ProtocolVersion1

		// ZZ: (..MessageV1)(ns25586.MessageV1)
		ns25587, ns25588 := ns25586.MessageV1.UnmarshalGOBE(src[offset:])
		offset += ns25587
		if !ns25588 {
			return
		}
	case ProtocolVersion1Encrypted: // Version == ProtocolVersion1Encrypted

		// ZZ: (..MessageV1Encrypted)(ns25586.MessageV1Encrypted)
		ns25589, ns25590 := ns25586.MessageV1Encrypted.UnmarshalGOBE(src[offset:])
		offset += ns25589
		if !ns25590 {
			return
		}
	}

	ok = true
	return
}

func (ns25591 *ProtocolVersion) SizeGOBE() uint64 {
	var ns25592 uint64

	// ZZ: (..ProtocolVersion)(*ns25591)

	// ZZ: (uint32)(*ns25591)
	ns25592 += 4

	return ns25592
}

func (ns25593 *ProtocolVersion) MarshalGOBE(dst []byte) uint64 {
	var ns25594 uint64

	// ZZ: (..ProtocolVersion)(*ns25593)

	// ZZ: (uint32)(*ns25593)
	_ = dst[ns25594+3]
	dst[ns25594+0] = byte(*ns25593 >> 0)
	dst[ns25594+1] = byte(*ns25593 >> 8)
	dst[ns25594+2] = byte(*ns25593 >> 16)
	dst[ns25594+3] = byte(*ns25593 >> 24)
	ns25594 += 4

	return ns25594
}

func (ns25595 *ProtocolVersion) UnmarshalGOBE(src []byte) (offset uint64, ok bool) {

	// ZZ: (..ProtocolVersion)(*ns25595)

	// ZZ: (uint32)(*ns25595)
	if uint64(len(src)) < offset+4 {
		return
	}
	_ = src[offset+3]
	*ns25595 = ProtocolVersion(
		uint32(src[offset+0])<<0 | uint32(src[offset+1])<<8 | uint32(src[offset+2])<<16 | uint32(src[offset+3])<<24)
	offset += 4

	ok = true
	return
}
